# MUX Code
#
# Instead of attempting to use DIV/MOD for the self-interpreter
# that simulates a 16-bit machine on larger machines we should
# use AND (by implementing it directly, or via using multiplex).
#
# Forth multiplex code:
#
#       :a opMux ( u1 u2 u3 -- u : bitwise multiplexor function )
#         \ tos contains multiplexor value
#         bwidth r0 MOV \ load loop counter initial value [16]
#         r1 ZERO       \ zero results register
#         r3 {sp} iLOAD --sp \ pop first input
#         r4 {sp} iLOAD --sp \ pop second input
#         
#         label: opMux.loop
#           r1 r1 ADD \ shift results register
#       
#           \ determine topmost bit of 'tos', place result in 'r2'
#           \ this is used to select whether to use r3 or r4
#           \ The following code *almost* works:
#           \ 
#           \    tos r2 MOV r2 INC r2 -if r4 r2 MOV else r3 r2 MOV then
#           \ 
#           \ But is not quite right.
#           tos -if label: opMuxR4 r4 r2 MOV else
#             tos r2 MOV
#             r2 INC r2 -if
#               opMuxR4 JMP ( space saving ) else
#               r3 r2 MOV then then
#       
#           \ determine whether we should add 0/1 into result
#           r2 -if r1 INC else r2 INC r2 -if r1 INC then then
#       
#           tos tos ADD \ shift tos
#           r3 r3 ADD \ shift r3
#           r4 r4 ADD \ shift r4
#           r0 DEC \ decrement loop counter
#           r0 +if opMux.loop JMP then
#         r1 tos MOV ;a \ move r1 to tos, returning our result
#
# And bitwise and in Forth SUBLEQ assembler:
#
#       :a opAnd
#         bwidth r0 MOV
#         x ZERO
#         r2 {sp} iLOAD
#         --sp
#         begin r0 while
#          x x ADD
#          tos r1 MOV r3 ZERO r1
#          -if r3 NG1! then r1 INC r1 -if r3 NG1! then
#          r2   r1 MOV r4 ZERO r1
#          -if r4 NG1! then r1 INC r1 -if r4 NG1! then
#          r3 r4 ADD two r4 ADD r3 ONE!
#          r4 if r3 ZERO then r3 x ADD
#          r2 r2 ADD
#          tos tos ADD
#          r0 DEC
#         repeat
#         x tos MOV ;a
#
