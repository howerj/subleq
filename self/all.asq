# Attempt to bring together three programs
# to make an N-bit SUBLEQ CPU into a 16-bit one,
# where N >= 16.
#
# For references, see the original files.
#
# TODO:
# - Get this working
# - Add back in documentation/References
# - Implement my own assembler in "debug.c"
# - Restore if negated, in mod code
# - Skip mod code if bit-width == 16
# - Fail if bit-width < 16


start:
0 0 (begin); # Jump over variables

. Z: zr: 0 tr:1 bits:1 max:-16 IOV: nr:-1
. tw:0 tx:0 ty:0 td:0 x:65536 y:1024 w:0 or:1 c:0 negated:0

begin:

count:
  zr
  nr bits;
  tr zr;
  zr tr;
  zr;
  zr tr (counted);
  max zr
  bits zr (counted);
  zr zr (count);
counted:
  zr;


## Self-interpreter

a1; pc Z; Z a1; Z;

a; a1:0 Z a2; a2:Z a; Z;

# Patch up operand 'A' if it is not -1
#
# if [a] != -1:
#    [a] = [a] + [len]
#
a1; a Z; Z a1; Z;   # [a1] = [a]
IOV a1 ?+3;         # If [a1] is negative, jump over next line
len a;              # [a] = [a] + [len] 

nr pc; # [pc] = [pc] + 1
b1; pc Z; Z b1; Z;
b; b1:0 Z b2; b2:Z b; Z;

# Patch up operand 'b' if it is not -1
#
# if [b] != -1:
#    [b] = [b] + [len]
#
b1; b Z; Z b1; Z;
IOV b1 ?+3;
len b;

# We need to copy 'pc' into 'c' and not use it directly later
# on as the SUBLEQ instruction might modify 'c', if it does
# the *old* value of 'pc' must be used (it would be more useful
# if the new value was used, however that is not the case).
#
nr pc;                 # [pc] = [pc] + 1
c1; pc Z; Z c1; Z;       # [c1] = [pc]
c; c1:0 Z c2; c2:Z c; Z; # [c] = [[c1]]


  # Division/Mod code...
  #
  # DIV/MOD w x y: m(y) = abs(m(x)) / m(w), m(tz) = abs(m(x)) % m(w), w > 0
  #
  tw; tx; ty; td; zr;
  x tw; tw tx;
  tw; w tw; tw ty;
  negated;

  # if (tx <= 0) { tx = -tx; }
  zr tx (negate);
  zr zr (noneg);
  negate:
    tx zr; zr td; tx; td tx;
    or negated;
  noneg:

  y;

  div:
    nr y;         # y++
    ty tx (dend); # x -= w, if x <= 0 JMP 'dend'
    zr zr (div);  # jump back to 'div', unconditionally
  dend:

  tw; tx tw; # tw = -tx;

  td;
  tx td;
  td ty; 

  td;
  or tw;         # tw--
  tw td (fix);   # if (td-tw <= 0) jump to fix
  ty ty (nofix); # else jump to no fix
  fix:
    or y;        # y--
  nofix:



# Execute the SUBLEQ instruction.
#
# Note that 'a' and 'b' have been modified from above.
#
# NB. The result stored in 'b' will need to subject to a signed
# modulo operation in order to emulate a 16-bit machine on
# machine widths larger than the current one, as this is an
# expensive operation this should be skipped by detecting the
# machine width and jumping over the modulo on 16-bit machines,
# when this is implemented...
#

a:0 b:0 leqz;   # Emulate subtraction / instruction
  nr pc;      # [pc] = [pc] + 1
  Z Z start;    # Jump back to beginning
leqz: 
  pc; c Z; Z pc; Z; # [pc] = [c]
  nr c (-1);    # Check if [c] is negative, halt if it is.
  len pc;         # [pc] = [pc] - [len]
  Z Z start;      # Jump back to the beginning

. pc:len+1 len:-? 


