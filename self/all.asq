# Attempt to bring together three programs
# to make an N-bit SUBLEQ CPU into a 16-bit one,
# where N >= 16.
#
# For references, see the original files.
#
# TODO:
# - Get this working
# - Add back in documentation/References
# - Implement my own assembler in "debug.c"
#
#


start:
0 0 (begin); # Jump over variables

. Z: zr: 0 tr:1 bits:1 max:-16 IOV: nr:-1
. tw:0 tx:0 ty:0 td:0 x:65536 y:1024 w:0 or:1 c:0

begin:

count:
  zr
  nr bits;
  tr zr;
  zr tr;
  zr;
  zr tr (counted);
  max zr
  bits zr (counted);
  zr zr (count);
counted:
  zr;


# Division code...
#
# DIV/MOD w x y: m(y) = abs(m(x)) / m(w), m(tz) = abs(m(x)) % m(w), w > 0
#
# TODO: Restore if negated

tw; tx; ty; td; zr;

x tw;
tw tx;

tw;
w tw;
tw ty;

# if (tx <= 0) { tx = -tx; }
zr tx (negate);
zr zr (noneg);
negate:
  tx zr; zr td; tx; td tx;
noneg:

y;

div:
  nr y;         # y++
  ty tx (dend); # x -= w, if x <= 0 JMP 'dend'
  zr zr (div);  # jump back to 'div', unconditionally
dend:

tw; tx tw; # tw = -tx;

td;
tx td;
td ty; 

td;
or tw;         # tw--
tw td (fix);   # if (td-tw <= 0) jump to fix
ty ty (nofix); # else jump to no fix
fix:
  or y;        # y--
nofix:


# Output values and halt
y (-1);
ty (-1);
0 0 (-1);




a1; pc Z; Z a1; Z;

a; a1:0 Z a2; a2:Z a; Z;

# Patch up operand 'A' if it is not -1
#
# if [a] != -1:
#    [a] = [a] + [len]
#
a1; a Z; Z a1; Z;   # [a1] = [a]
IOV a1 ?+3;         # If [a1] is negative, jump over next line
len a;              # [a] = [a] + [len] 

nr pc; # [pc] = [pc] + 1
b1; pc Z; Z b1; Z;
b; b1:0 Z b2; b2:Z b; Z;

# Patch up operand 'b' if it is not -1
#
# if [b] != -1:
#    [b] = [b] + [len]
#
b1; b Z; Z b1; Z;
IOV b1 ?+3;
len b;

# We need to copy 'pc' into 'c' and not use it directly later
# on as the SUBLEQ instruction might modify 'c', if it does
# the *old* value of 'pc' must be used (it would be more useful
# if the new value was used, however that is not the case).
#
nr pc;                 # [pc] = [pc] + 1
c1; pc Z; Z c1; Z;       # [c1] = [pc]
c; c1:0 Z c2; c2:Z c; Z; # [c] = [[c1]]

# Execute the SUBLEQ instruction.
#
# Note that 'a' and 'b' have been modified from above.
#
# NB. The result stored in 'b' will need to subject to a signed
# modulo operation in order to emulate a 16-bit machine on
# machine widths larger than the current one, as this is an
# expensive operation this should be skipped by detecting the
# machine width and jumping over the modulo on 16-bit machines,
# when this is implemented...
#

a:0 b:0 leqz;   # Emulate subtraction / instruction
  nr pc;      # [pc] = [pc] + 1
  Z Z start;    # Jump back to beginning
leqz: 
  pc; c Z; Z pc; Z; # [pc] = [c]
  nr c (-1);    # Check if [c] is negative, halt if it is.
  len pc;         # [pc] = [pc] - [len]
  Z Z start;      # Jump back to the beginning

. pc:len+1 len:-? 


