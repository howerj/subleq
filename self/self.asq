# SUBLEQ Self Interpreter
#
# This is a "Self Interpreter" for SUBLEQ, that is, it is
# an interpreter that executes a SUBLEQ program written
# for a SUBLEQ machine. It expects the SUBLEQ program to be
# appended to the end of this program, as such it has to patch
# up the program and subtract the length of this program from
# each of the cells before execution, excepting the special
# addresses for when one of the operands is negative one.
#
# A single SUBLEQ instruction is written as:
#
# 	SUBLEQ a, b, c
#
# Which is as there is only one instruction possible, SUBLEQ,
# is often just written as:
#
# 	a b c
#
# These three operands are stored in three continuous memory
# locations. Each operand is an address, They perform the 
# following pseudo-code:
#
# 	[b] = [b] - [a]
# 	if [b] <= 0:
# 		goto c;
# 	
# There are three special cases, if 'c' is negative then
# execution halts (or sometimes if it is refers to somewhere
# outside of addressable memory). The other two are for Input
# and Output. If 'a' is -1 then a byte is loaded from input
# into address 'b', if 'b' is negative then a byte is output
# from address 'a'.
#
# Note that apart from I/O nothing is said about how numbers
# are represented, what bit length they are (or if each cell is 
# an arbitrary precision number) and how negative numbers
# implemented (twos' compliment, sign magnitude, etcetera).
# Usually two's complement is used, but 8, 16, 32 and 64-bit
# versions of SUBLEQ are all common, with 32-bit versions being
# the most so.
#
# Despite the simplicity of the instruction set it is possible
# to compute anything computable with it (given infinite memory 
# and time).
#
# To implement anything non-trivial self-modifying code is
# very common. This program is no exception.
#
# The self interpreter is actually quite simple to implement
# for this language.
#
# The original SUBLEQ self interpreter was from:
#
# <https://eigenratios.blogspot.com/2006/08/self-written-self-modifying-self.html>
# (Written by Clive Gifford, 29/30 August 2006).
#
# However it does not deal with I/O.
#
# An improved version deals with output, but not input is
# available from:
#
# <http://mazonka.com/subleq/>
#
# Which is a deal link as of 03/01/2023, an archived version
# is available at:
#
# <https://archive.ph/8EYZv> 
# 
# This version deals with input and output and has fewer
# superfluous instructions.
#
# TODO:
# 	- Comment everything.
# 	- Translate to Forth?
# 	- Make an inline version, which would not subtract 
# 	the length of the program from the operands.
#	- Make a 16-bit only version, this requires a signed
#	modulo operation.
#	- Add this program to the book, for a second edition?
#	- Could use this to make a debugger within SUBLEQ
#	instead of as a separate program, which might be useful
#	in an MS-DOS like SUBLEQ environment.
#       - If the inline version is used within the main Forth
#       image, it could be made into an instruction for the VM
#       as well, allowing (relatively) fast emulation from 
#       within the Forth environment.
#
## Notes on the SUBLEQ assembler:
#
# * Statements are terminated by ';' or new lines.
# * Each statement is a single SUBLEQ instruction.
# * Labels are denoted with ':' and are used for both
# data and jump locations, the initial value is an expression
# to the right of the colon which will be placed at the memory
# location of the labels.
# * Operands can be omitted, in which case default values
# will be used. 
# * If the last operand, the jump location is omitted, it
# will be replaced with the location of the next instruction.
# * If both of the last two operands are omitted then the
# last will be replaced with the location of the next
# instruction and the second operand will be replaced with a 
# copy of the first operand, effectively zeroing the contents 
# at the location of the first operand.
# * '?' represents the address of the next cell, not the 
# next instruction.
#
## Special Registers
#
# * 'Z', A register that should start and end up as zero,
# it is known as the Zero Register. 
# * 'pc', the program counter for the simulated device.
# * 'IOV', contains the value for the special I/O address
# values. This stands for I/O Value.
# * 'neg1', contains negative one. Used for incrementing
# usually be subtracting negative one against a value. The
# same value is used for 'IOV'.
# * 'len', contains the length of this program image, as
# such the variable must be the last one defined in the file.
# * 'a', Operand 'a' of SUBLEQ instruction
# * 'b', Operand 'b' of SUBLEQ instruction
# * 'c', Operand 'c' of SUBLEQ instruction
# * 'a1', used to load 'a' before indirection and as temp reg
# * 'b1', used to load 'b' before indirection and as temp reg
# * 'c1', used to load 'c' before indirection and as temp reg
#
# On to the program itself:
#

start:

# Load PC: [a1] = [pc]
a1; pc Z; Z a1; Z;

# [a] = [[a1]] (after modification from above)
a; a1:0 Z a2; a2:Z a; Z;

# Patch up operand 'A' if it is not -1
#
# if [a] != -1:
#    [a] = [a] + [len]
#
a1; a Z; Z a1; Z;   # [a1] = [a]
IOV a1 ?+3;         # If [a1] is negative, jump over next line
len a;              # [a] = [a] + [len] 

neg1 pc; # [pc] = [pc] + 1
b1; pc Z; Z b1; Z;
b; b1:0 Z b2; b2:Z b; Z;

# Patch up operand 'b' if it is not -1
#
# if [b] != -1:
#    [b] = [b] + [len]
#
b1; b Z; Z b1; Z;
IOV b1 ?+3;
len b;

# We need to copy 'pc' into 'c' and not use it directly later
# on as the SUBLEQ instruction might modify 'c', if it does
# the *old* value of 'pc' must be used (it would be more useful
# if the new value was used, however that is not the case).
#
neg1 pc;                 # [pc] = [pc] + 1
c1; pc Z; Z c1; Z;       # [c1] = [pc]
c; c1:0 Z c2; c2:Z c; Z; # [c] = [[c1]]

# Execute the SUBLEQ instruction.
#
# Note that 'a' and 'b' have been modified from above.
#
# NB. The result stored in 'b' will need to subject to a signed
# modulo operation in order to emulate a 16-bit machine on
# machine widths larger than the current one, as this is an
# expensive operation this should be skipped by detecting the
# machine width and jumping over the modulo on 16-bit machines,
# when this is implemented...
#

a:0 b:0 leqz;   # Emulate subtraction / instruction
  neg1 pc;      # [pc] = [pc] + 1
  Z Z start;    # Jump back to beginning
leqz: 
  pc; c Z; Z pc; Z; # [pc] = [c]
  neg1 c -1;    # Check if [c] is negative, halt if it is.
  len pc;         # [pc] = [pc] - [len]
  Z Z start;      # Jump back to the beginning

# Declare and set some registers, 'len' must be last.
. Z:0 pc:len+1 c:0 IOV: neg1:-1 len:-? 

## https://eigenratios.blogspot.com/2006/08/self-written-self-modifying-self.html
##
## Self interpreter for OISC ("One Instruction Set Computer") using "subleq".
##
## This uses "subleq" as the "one instruction" where A, B and C are memory
## addresses, and in the explanations and comments [A] means the integer value
## stored at address A. Memory is a zero based array of integers of some
## suitable "width". Signed 32 bit values are perfectly adequate.
##
## A single "subleq" instruction written like this
##
##    subleq A B C
##
## and is stored in memory as three addresses A B and C in consecutive
## locations. The following pseudocode describes what happens when one
## instruction is executed.
##
##    [B] = [B] - [A]
##    if [B] <= 0 goto C
##
## Note that value of C is taken to be the value before the subtraction.
##
## Omitting the C operand (i.e. writing just "subleq A B") is understood to be
## shorthand for specifying C as the address of the next instruction. When the
## program starts running, the program counter is 0. It halts when a branch
## to a negative address happens.
##
## This self-interpreter expects the program that it should run to appear
## directly after its own code/data in memory.
##
## Written by Clive Gifford, 29/30 August 2006 based on the Wikipedia
## description of a OISC using the "subleq" instruction.
#
#start:
#
## [A1] = [PC]
#
#      subleq A1   A1
#      subleq PC   ZERO
#      subleq ZERO A1
#      subleq ZERO ZERO
#
## Code below (after modification from above) is equivalent to [A] = [[A1]]
#
#      subleq A    A
#A1:   data   0
#      data   ZERO
#      data   A2
#A2:   subleq ZERO A
#      subleq ZERO ZERO
#
## [A] = [A] + [LEN]
#
#      subleq LEN  ZERO
#      subleq ZERO A
#      subleq ZERO ZERO
#
## [B1] = [PC] + 1
#
#      subleq B1   B1
#      subleq PC   ZERO
#      subleq ZERO B1
#      subleq ZERO ZERO
#
#      subleq NEG1 B1
#
## Code below (after modification from above) is equivalent to [B] = [[B1]]
#
#      subleq B    B
#B1:   data   0
#      data   ZERO
#      data   B2
#B2:   subleq ZERO B
#      subleq ZERO ZERO
#
## [B] = [B] + [LEN]
#
#      subleq LEN  ZERO
#      subleq ZERO B
#      subleq ZERO ZERO
#
## We have to copy [C] now, just in case the emulated subtraction modifies [[PC] + 2].
## [C1] = [PC] + 2
#
#      subleq C1    C1
#      subleq PC    ZERO
#      subleq ZERO  C1
#      subleq ZERO  ZERO
#
#      subleq NEG2  C1
#
## Code below (after modification from above) is equivalent to [C] = [[C1]]
#
#      subleq C    C
#C1:   data   0
#      data   ZERO
#      data   C2
#C2:   subleq ZERO C
#      subleq ZERO ZERO
#
## [[B]] = [[B]] - [[A]];
## if [[B]] <= 0 goto LEQZ
#
## Earlier code referring to addresses A and B has modified the next
## couple of words to create the equivalent of "subleq [A] [B] LEQZ"
## This is where we're "emulating" the subtraction...
#
#A:    data   0
#B:    data   0
#      data   LEQZ
#
## [PC] += 3
#
#      subleq NEG3  PC
#      subleq ZERO  ZERO START
#
## We come to address LEQZ when the emulated subleq is going to take
## the branch to the emulated address C.
#
#LEQZ:
#
## First save the "raw" value in PC
## [PC] = [C]
#
#      subleq PC    PC
#      subleq C     ZERO
#      subleq ZERO  PC
#      subleq ZERO  ZERO
#
## Check if [C] is less than zero. Halt if it is. 
## We don't care about changing [C] as we've already copied the value to [PC] above.
#
#      subleq NEG1  C     -1
#
## [PC] = [PC] + [LEN]
#
#      subleq LEN   ZERO
#      subleq ZERO  PC
#      subleq ZERO  ZERO  START
#
#NEG3: data  -3
#NEG2: data  -2
#NEG1: data  -1
#ZERO: data   0
#
#C:    data   0
#PC:   data   PROG
#LEN:  data   PROG
#
## Code for the program to be interpreted must start at the PROG address...
#PROG:
#
#
## Assembled:
## 15  15   3
## 134 132   6
## 132  15   9
## 132 132  12
##  96  96  15
##   0 132  18
## 132  96  21
## 132 132  24
## 135 132  27
## 132  96  30
## 132 132  33
##  51  51  36
## 134 132  39
## 132  51  42
## 132 132  45
## 131  51  48
##  97  97  51
##   0 132  54
## 132  97  57
## 132 132  60
## 135 132  63
## 132  97  66
## 132 132  69
##  87  87  72
## 134 132  75
## 132  87  78
## 132 132  81
## 130  87  84
## 133 133  87
##   0 132  90
## 132 133  93
## 132 132  96
##   0   0 105
## 129 134 102
## 132 132   0
## 134 134 108
## 133 132 111
## 132 134 114
## 132 132 117
## 131 133  -1
## 135 132 123
## 132 134 126
## 132 132   0
##  -3
##  -2
##  -1
##   0
##   0
## 136
## 136

